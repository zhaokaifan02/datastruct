# 排序应用

按照某个顺序对商品之类的进行排序。
非常重要
价值在于帮助我们筛选，把想要的定到前面来
# 插入排序
像打扑克牌一样。
选取一个元素后，把他插入到一个已有顺寻的序列中，使得插入后的序列依然是有序的。
重复这个过程。
**重点** 重点在于如何保持这个数依旧有序
从后往前，如果比你小，就往后移，直到不小为止

## 实际操作
有一个数列
9 1 2 5 7 4 8 6 3 5
把第一个数字9当成有序数列，把第二个数当成要插入的数，第一次调整为
1 9 2 5 7 4 8 6 3 5 t1

1 2 9 5 7 4 8 6 3 5 t2

1 2 5 9 7 4 8 6 3 5 t3

1 2 5 7 9 4 8 6 3 5 t4
...等

## 复杂度分析
O($n^2$)
最坏： 逆序 每次都要交换前面的数

traverse 1+2+3+4+。。。+N-1

最好： 顺序有序

有序，或者接近有序的时候，消耗最小

## vs其他排序
### 与冒泡相比
两者复杂度相同都是 O（n^2）
但实际上
对于 1 2 3 4 5 6 8 7 这个只需要微小扰动的

插入要比较 1 + 1 +1 + 1 + 1 + 1 + 2 次

冒泡的话 需要比 1 +1 + 1+ 1+1+1 +1 7次 + 6次，需要在比较依次，确定exchange是否仍然有序

所以接近有序的话插入更优，因为冒泡永远多完，**是在整体角度考虑的**

插入有序慢慢考虑的，所以在**局部有序或者接近有序**，插入排序更优秀  

# 希尔排序
缩小增量排序。
对插入排序的优化
影响插入排序效率的是，完全逆序
最好O（n）顺序有序  或者接近顺序有序
希尔排序的思想就是想让他变成顺序有序或者接近有序
1. 预排序
2. 直接插入排序
## 预排徐
大的数更快的到后面，小的数更快的到前面
分组排序
gap = 3时

9 1 2 5 7 4 8 6 3 5

9 5 8 5 g1

1 7 6 g2

2 4 3 g3
 

**gap为几就分成几组**
对于 第一个gap组  9 5 8 5进行插入排序 得到 

5 9 8 5 

5 8 9 5

5 5 8 9 

这样对三个gap都排得到三个如下
5 5 8 9
1 6 7
2 3 4 
实际上的变成为
5 1 2 5 6 3 8 7 4 9 这样大的数就到后面了

这种思想在逆序时效果更明显 gap = 3
9 8 7 6 5 4 3 2 1  
9 6 3  => 3 6 9
8 5 2  => 2 5 8
7 4 1  => 1 4 7
3 2 1 6 5 4 9 8 7 更接近有序了

**gap越小越接近有序**
**gap越大大的数更快到后面，小的数更快到前面**
## 分析复杂度
预排序的复杂度是多少，
Gap很大时差不多是O（n），跳的很快On
Gap很小时也是 O（n），有序了是On
循环 n/3/3/3/3/3 = 1次
$3^x = 1$解得 $log_3{n}$
现在是$nlog_3{n}$
平均是$n^{1.3}$左右

# 冒泡排序
每次确定一个最大值（最小值）每次确定一个最终位置
一趟排序的时候，交换两个数，把最大的慢慢浮上来
9 1 2 5 7 4 8 6 3 5 
1 2 5 7 4 8 6 3 5 9 t1 
1 2 5 4 7 6 3 5 8 9 t2
1 2 4 5 6 3 5 7 8 9 t3
1 2 4 5 3 5 6 7 8 9 t4

## 时间复杂度
O(n^2) 
最好： 已经是有序，不需要执行if里的swap
最坏： 完全逆序，执行 N-1, N-2 ,N-3 ,,, 1次逆序


# 选择排序
traverse 一遍，选择最大的，放到应该放的位置
9 1 2 5 7 4 8 6 3 5 
5 1 2 5 7 4 8 6 3 9 拿9放到尾，这时候
5 1 2 5 7 4 3 6 8 9 拿8放到次尾
5 1 2 5 6 4 3 7 8 9 选到7，与应该放的地方交换位置

O(n^2)
## 优化版本
一口气选两个，左右都选

# 快速排序
选出一个关键字，做一个单趟排序
单趟排序
1. 选出一个key，一般是第一个数或者最后一个数
要求：
左边的比key小，右边的比key大
左右两个指针，左边选一个比key大的，右边选一个比key小的
两边都选中的时候交换。
这样保证左右相遇时左边没有比key大的，右边没有比key小的。这样就完美的化成了两个
**注意**（问题在同时走的话不一定都能拿到底）
交换完之后R先走，碰到交换玩还没动的L，这里L一定是刚换过来的比key小的
右边做key的话，最后保留的位置一定是比key大的，这样让，L去碰R，这样子R下一定是L比key大的刚刚换过来的
```
void Quick_Sort(int* a, int start,int end)
{

    int key = a[0]; //左边是key
    int left = start;
    int right = end;
    while(left<right)
    {
        //右边找小
        while(left<right && a[right]>key) //找小，这种递归式的
        {
            --right;
        }
        //left<right有两个作用
        //1. 防止right--越界
        //2. 确保是left撞的right，保证right是里存的是left上一次换过来的小的，从而保证key换到a[0]里是小的
        //左边找大
        while(left<right && a[left]<key)
        {
            ++left;
        }
        Swap(&a[left],&a[right]);
    }
    Swap(&a[0],&a[left]); //这里left等于right，排完后放到正确的位置
}

```
2. 递归
排完之后，数组中一个数的位置已经定西来了，key不需要动了
对左边进行快排，右边进行快排。
使用分治的思路就拿下了
像二叉树的思路一样，左边排完右边排完

# 